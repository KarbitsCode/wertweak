/****************************************************************************
 *
 *            WerTweak
 *
 *            Copyright (c) 2025 Tim De Baets
 *
 ****************************************************************************
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * This Source Code Form is "Incompatible With Secondary Licenses", as
 * defined by the Mozilla Public License, v. 2.0.
 *
 ****************************************************************************
 *
 * Implementation of IAT hook of WerFault.exe
 *
 ****************************************************************************/

#include "pch.h"

#include <DelayLoadUtils.h>

#include "PEUtils.h"
#include "WERFaultHook.h"

static const LPCSTR g_szProcessSnapshotApiSetName = "api-ms-win-core-processsnapshot-l1-1-0.dll";

static const LPCSTR g_szPssQuerySnapshotName = "PssQuerySnapshot";

typedef DWORD (WINAPI *PPSS_QUERY_SNAPSHOT) (HPSS                           SnapshotHandle,
                                             PSS_QUERY_INFORMATION_CLASS    InformationClass,
                                             void                          *Buffer,
                                             DWORD                          BufferLength);
/*
 * Dummy function (that must never be inlined) that just returns the given process snapshot handle
 * pointer, so that this pointer is in EAX/RAX and the snapshot handle can be read/modified by the
 * debugger (i.e. WerTweakInject).
 */
__declspec(noinline) HPSS *GetSnapshotHandlePtr(HPSS *phSnapshot)
{
    return phSnapshot;
}

TRANSLATE_HPSS_FUNC HPSS TranslateSnapshotHandleByDebugger(HPSS hSnapshot)
{
    HPSS    hNewSnapshot    = hSnapshot;
    HPSS   *phNewSnapshot   = &hNewSnapshot;

    /*
     * The following code was verified to be compiled by VS Community 2019 into the proper assembly
     * code so that the value of EAX/RAX is equal to phNewSnapshot right before the INT3 breakpoint
     * generated by __debugbreak(), by using x32dbg/x64dbg, for debug/release x86/x64 (even though
     * process snapshot handle translation is only needed/supported on x64, see comment in
     * WerTweakInject.cpp:HandleTranslateProcessSnapshotHandle.
     */
    if (IsDebuggerPresent())
    {
        /*
         * We must pass the snapshot handle by reference here to allow the debugger (i.e.
         * WerTweakInject) to modify its value. Passing the handle by value won't work (the
         * generated assembly code would restore the register to its original value after the
         * breakpoint).
         */
        phNewSnapshot = GetSnapshotHandlePtr(phNewSnapshot);
        
        /*
         * Trigger an INT3 breakpoint by calling the __debugbreak() intrinsic. Note that the address
         * of this breakpoint is being checked by WerTweakInject so we cannot use the DebugBreak()
         * API function here (because then the address would be in KernelBase.dll instead of in this
         * DLL).
         */
        __debugbreak();
    }

    return *phNewSnapshot;
}

PVOID g_pPrevPssQuerySnapshot = NULL;

DWORD WINAPI NewPssQuerySnapshot(HPSS                           SnapshotHandle,
                                 PSS_QUERY_INFORMATION_CLASS    InformationClass,
                                 void                          *Buffer,
                                 DWORD                          BufferLength)
{
    DWORD dwResult;

    DbgOut("PssQuerySnapshot(0x%p)", SnapshotHandle);

    SnapshotHandle = TranslateSnapshotHandleByDebugger(SnapshotHandle);

    DbgOut("  handle after translation: 0x%p", SnapshotHandle);

    dwResult = ((PPSS_QUERY_SNAPSHOT)g_pPrevPssQuerySnapshot)(SnapshotHandle,
                                                              InformationClass,
                                                              Buffer,
                                                              BufferLength);

    DbgOut("  result=%u", dwResult);

    return dwResult;
}

void CWERFaultHook::HookWERFault()
{
    WalkImportModules();
}

void CWERFaultHook::PatchImportedModule(PIMAGE_THUNK_DATA pOrigFirstThunk,
                                        PIMAGE_THUNK_DATA pFirstThunk)
{
    PIMAGE_THUNK_DATA pOrigThunk    = pOrigFirstThunk;
    PIMAGE_THUNK_DATA pThunk        = pFirstThunk;

    while (pOrigThunk->u1.AddressOfData && pThunk->u1.AddressOfData)
    {
        PIMAGE_IMPORT_BY_NAME   pImport     = NULL;
        const char             *importName  = NULL;

        // Ignore imports by ordinal
        if (pOrigThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG)
            goto next;

        pImport     = (PIMAGE_IMPORT_BY_NAME)RVAToAbsolute(pOrigThunk->u1.AddressOfData);
        importName  = pImport->Name;

        if (lstrcmpA(importName, g_szPssQuerySnapshotName) == 0)
        {
            // TODO: add error checking
            PatchImport(pThunk, NewPssQuerySnapshot, (PVOID *)&g_pPrevPssQuerySnapshot);
        }

next:

        pOrigThunk++;
        pThunk++;
    }
}

bool CWERFaultHook::ImportModuleProc(PIMAGE_IMPORT_DESCRIPTOR  pImpDesc,
                                     const char               *name)
{
    PIMAGE_THUNK_DATA pOrigFirstThunk   = NULL;
    PIMAGE_THUNK_DATA pFirstThunk       = NULL;

    if (lstrcmpiA(name, g_szProcessSnapshotApiSetName) == 0)
    {
        pOrigFirstThunk = (PIMAGE_THUNK_DATA)RVAToAbsolute(pImpDesc->OriginalFirstThunk);
        pFirstThunk     = (PIMAGE_THUNK_DATA)RVAToAbsolute(pImpDesc->FirstThunk);

        PatchImportedModule(pOrigFirstThunk, pFirstThunk);
    }

    return true;
}
